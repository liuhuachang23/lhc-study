
1、this关键字
    1. this关键字可以用来访问本类的属性、方法、构造器
    2. this用于区分当前类的属性和局部变量
    3. 访问成员方法的语法：this.方法名(参数列表);
    4. 访问构造器语法：this(参数列表);注意只能在构造器中使用
    5. this不能在类定义的外部使用，只能在类定义的方法中使用。
    6. 记住一句话，那个对象调用，this就代表那个对象

2、封装
    封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起 数
    据被保护在内部,程序的其它部分只有通过被授权的操作[方法],才能对数据进行操作。

    封装的好处：
        1）良好的封装能够减少耦合
        2）类内部的结构可以自由修改
        3）可以对成员进行更精确的控制 (比如：对数据进行验证，保证安全合理)
        4）隐藏实现细节

    封装的实现步骤
        1）属性私有化

        2）对外提供一个公共的set方法，用于对属性判断并赋值
            public void setXxx(){
                //加入数据验证的业务逻辑
                属性 = 参数名;
            }

        3）提供一个公共的get方法，用于获取属性的值
            public XX getXxx(){
                return xx;
            }


3、继承
    继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，
    新的类能吸收已有类的数据属性和行为，并能扩展新的能力。
    总结：
        1）子类具有父类的所有属性和方法，但只能直接访问非private的属性和方法
        2）子类可以扩展父类没有的属性和方法
        3）子类可以重写父类的方法


    继承带来的便利
        1）代码的复用性提高了
        2）代码的扩展性和可维护性提高了

    继承细节
        1）子类继承了父类的所有属性和方法，非私有属性和方法，可以在子类直接访问，
            但是私有属性和方法不能在子类直接访问，要通过父类提供的公共方法去访问

        2）子类必须调用父类的构造器，完成父类的初始化

        3）当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无
            参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指
            定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过

        4） 如果希望指定去调用父类的某个构造器，则显式的调用一下
        5） super在使用时，需要放在构造器第一行
        6） super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器

    继承的限制
         限制一：一个子类只能够继承一个父类，存在单继承局限。
         限制二：在一个子类继承的时候，实际上会继承父类之中的所有操作（属性、方法），
                但是需要注意的是，对于所有的非私有（no private）操作属于显式继承（可以直接利用对象操作），
                而所有的私有操作属于隐式继承（间接完成）
         限制三：在继承关系之中，如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，
                之后再调用子类构造，为子类之中的属性初始化，即：默认情况下，子类会找到父类之中的无参构造方法。
                默认调用的是无参构造，而如果这个时候父类没有无参构造，则子类 必须 通过super()调用指定参数的构造方法

4、super关键字

    基本介绍：
        super代表父类的引用，用于访问父类的属性、方法、构造器
        1）访问父类的属性，但不能访问父类的private属性
            super.属性名
        2）访问父类的方法，不能访问父类的private方法
            super.方法名(参数列表)；
        3）访问父类的构造器(这点前面用过）：
            //只能放在构造器的第一句，只能出现一句！
            super(参数列表);

    带来的好处/细节
        1）调用父类的构造器的好处 （分工明确，父类属性由父类初始化，子类的属性由子类初始化）
        2）当子类中有和父类中的成员（属性和方法） 重名时，为了访问父类的成员，必须
            通过super。如果没有重名，使用super、this、直接访问是一样的效果！[举例]

        3）super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用
            super去访问爷爷类的成员；如果多个基类中都有同名的成员，使用super访问遵循就近原则。A->B->C
            注意：如果A、B 类都有一个同名属性，假如B类中的那个是私有的，那么使用super.属性名的方式去访问
                会报错，（因为B类中的那个属性是私有的不能直接访问，也不能跳过B类去访问A类中的那个属性）

    super和this的比较

    No     区别点               this                              super

    1     访向属性         访问本类中的属性，如果本类               访问父类中的属性
                          没有此属性则从父类中继续查找

    2     调用方法         访问本类中的方法,如果本类                直接访问父类中的方法
                          没有此方法则从父类继续查找.

    3    调用构造器        调用本类构造器，必须放在构造器的首行       调用父类构造器，必须放在子类构造器的首行

    4       特殊          表示当前对象                             子类中访问父类对象

5、多态
    一个对象具备多种形态，也可以理解为事物存在的多种体现形态
    （父类的引用类型变量指向了子类对象，或者是接口的引用类型变量指向了接口实现类的对象）

    多态的前提：
        1）具有继承或实现关系
        2）要有方法的重写

        1）直接调用属性没有重写之说，属性的值看的是编译类型 （package hsp.chapter07.poly_.PolyExercise02）

    java的动态绑定机制 （hsp.chapter07.poly_.dynamic_）
        1）当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
        2）当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

    多态的使用







