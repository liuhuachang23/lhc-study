线程

    1. 程序：是为了完成特定任务，用某种语言编写的一组指令的集合，简单的说就是 我们写的代码

    2. 进程：
        1） 进程是指运行中的程序，比如我们使用QQ，就启动了通过进程，操作系统就会为该进程分配空间。
            当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配型的内存空间
        2） 进程是程序的一次执行过程，或是正在运行的一个程序。
            是动态过程：有它自身的产生，存在和消亡的过程

    3. 线程：
        1） 线程由进程创建的，是进程的一个实体
        2） 一个进程可以拥有多个线程

    4. 单线程和多线程
        1）单线程：同一时刻，只允许执行一个线程
        2）多线程：同一时刻，可以执行多个线程，
            比如：一个qq进程，可以同时打开多个聊天窗口。一个迅雷进程，可以同时下载多个文件

    5. 并发与并行
        1）并发：同一时刻，多个任务交替执行（频率非常快），造成一种 "貌似同时" 的错觉。
                简单的说，单核cpu实现的朵任务就是并发
        2）并行：同一时刻，多个任务同时执行。多核cpu，可以实现并行
        3）并发与并行可以同时存在

    6. 创建线程的两种方式
        1） 继承Thread类，重写run方法
            （Thread类也是实现了Runnable接口）
        2） 实现Runnable接口，重写run方法

        继承Thread和实现Runnable接口的区别
            1） 从java的设计来看,通过继承Thread或者实现Runnable接口来创建线程本质上没有区别(start() -> start0())
                从jdk帮助文档我们可以看到Thread类本身就实现了Runnable接口
            2） 实现了Runnable接口方式更加适合多个线程共享一个资源的情况, 并且避免了单继承限制:

                T3 t3 = new T3();
                Thread thread1 = new Thread(t3);
                Thread thread2 = new Thread(t3);
                thread1.start();
                thread2.start();
                两个线程都在执行一个对象, 所以达到了共享资源的情况 


    7、线程的使用 【package hsp.chapter16.threaduse;】
        1）多线程机制
            第一种：继承Thread类 【Thread01】

            第二种：实现Runnable接口【Thread02】
                    使用到了代理模式
                    案例 【Proxy】模拟了代理模式

        2）演示多线程执行【Thread03】

    8、使用多线程模拟售票系统 【package hsp.chapter16.ticket;】

        通过此案例，发现程序会出现 超卖现象

    9、线程终止 【package hsp.chapter16.exit_;】

        1) 当线程完成任务后,会自动终止
        2) 还可以通过使用变量来控制run方法退出的方式,来停止线程,即通知方式

    10、线程常用方法 【package hsp.chapter16.method;】

        线程常用方法01 【ThreadMethod01】
            1） setName 设置线程名称，使之与参数name相同
                - Thread.currentThread().setName 表示修改本线程的名称
                - t1.setName 表示修改t1线程的名称
            2） getName 返回该线程名称
                - Thread.currentThread().getName() 表示调用本线程的名称
                - t1.getName() 表示调用t1线程的名称
            3） start 使线程开始执行；java虚拟机底层调用该线程的 start0()
            4） run 调用线程对象run方法
            5） setPriority 更改线程的优先级
            6） getPriority 获取线程的优先级
            7） sleep 在指定的毫秒数内让当前正在执行的线程休眠
            8） interrupt 中断线程
        注意事项和细节
            1） start 底层会创建新的线程，调用run，run就是一个简单的方法调用，不会启动新线程
            2） 线程优先级的范围 MIN_PRIORITY(1)、NORM_PRIORITY(5)、NAX_PRIORITY(10)
            3） interrupt 中断线程，但并没有真正的中断线程，一般用于中断正在休眠的线程（让其停止休眠，继续工作）
            4） sleep 线程的静态方法，使当前线程休眠

        线程常用方法02 【ThreadMethod02】
            1） yield：线程的礼让。
                  让其它线程执行，但礼让的时间不确定，也不一定礼让成功（由cpu决定）
            2） join：线程的插队。
              插队的线程一旦插队成功，则会先执行完插入线程的所以任务

            说明一下：假如现在有两个线程 t1、t2
            t1.yield() 就是t1主动让出cpu，让t2执行，礼让的时间不确定，也不一定礼让成功（由cpu决定）
            t1.join() 就是t1去插t2 的队，t1一旦插队成功，则会先执行完t1的所以任务，再让t2继续执行

        线程常用方法03
            用户线程和守护线程
            1） 用户线程：也叫工作线程，当线程的任务执行完或通知方式结束
            2） 守护线程：一般是为了线程服务的，当所有的用户线程结束，守护线程自动结束
            3） 常见的守护线程：垃圾回收机制

    11、线程的生命周期 【package hsp.chapter16.state_;】

          JDK中用Thread.State枚举表示了线程的几种状态
            1） NEW 尚未启动的线程 处于此状态
            2） RUNNABLE（可运行状态） 在java虚拟机中执行的线程 处于此状态（可分为 Ready就绪状态、Running运行状态）
                  start()调用start0()后进入RUNNABLE 该线程并不会立马执行，只是将线程变成了RUNNABLE的Ready，
                  具体什么时候执行，取决于CPU，由CPU统一调度，线程被调度器选中执行（变成 Running）

            3） BLOCKED 被阻塞等待监视器锁定的线程 处于此状态
            4） WAITING（等待状态） 正在等待另一个线程执行特定动作的线程 处于此状态
            5） TIMED_WAITING（超时等待状态） 正在等待另一个线程执行动作到达指定等待时间的线程 处于此状态
            6） TERMINATED  已退出的线程 处于此状态


    12. Synchronized 【package hsp.chapter16.synchronized_;】

        线程同步机制
        1）在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，
           保证数据在任何同一时刻，只能允许一个线程访问，以保证数据的完整性
        2）也可以理解：线程同步，即当一个线程在对内存进行操作时，其他线程不可以对这个
           内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作

        实现同步的方式
        1）同步代码块
            普通代码块：锁为当前对象
            synchronized (对象/this) { //得到对象的锁，才能操作同步代码
                //需要被同步的代码；
            }
            静态方法的代码块中：锁为当前类
            synchronized (类名.class) { //得到对象的锁，才能操作同步代码
                //需要被同步的代码；
            }
        2）放在方法声明中，表示整个方法为-同步方法
            普通方法：锁为当前对象
            public synchronized void m (String name) {
                //需要被同步的代码
            }
            静态方法：锁为当前类
            public synchronized static void m (String name) {
                //需要被同步的代码
            }

       互斥锁
        1）在java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性
        2）每个对象都对应与一个可称为 "互斥锁" 的标记，这个标记用来保证在任意时刻，只能有一个线程访问该对象
        3）关键字synchronized 来与对象的互斥锁联系，当某个对象用synchronized 修饰时，表明该对象在任意时刻只能由一个线程访问
        4）同步的局限性：导致程序的执行效率要降低
        5）同步方法（非静态的）的锁可以是this，也可以是其他对象（要求是同一个对象）
        6）同步方法（静态的）的锁为当前类本身

        互斥锁注意事项和细节
        1）同步方法如果没有素拓static修饰，默认锁的对象为：this
        2）如果方法有static修饰，默认锁的对象为：当前类.class
        3）实现的落地步骤
            需要先分析上锁的代码
            选择同步代码块或者同步方法，优先选择同步代码块（作用范围小，效率高，因为上锁效率降低）
            要求多个线程的锁对象为同一个即可

        线程的死锁
        多个线程占用了对方的锁资源，但不肯相让，导致死锁，在实际编程一定要避免死锁的发生

        释放锁
            下面操作会释放锁
            1）当前线程的同步方法，同步代码块执行结束
            2）当前线程在同步代码块，同步方法中遇到break、return
            3）当前线程在同步代码块、同步方法中出现了为处理的Error或者Exception，导致异常结束
            4）当线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁

            下面操作不会释放锁
            1）线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法
               暂停当前线程的执行，不会释放锁
            2）线程执行同步代码块时，其他线程调用了该线程的suspend()方法该线程挂起，该线程不会释放锁
            提示：应尽量避免使用suspend()和resume()来控制线程，这两种方法不在推荐使用




