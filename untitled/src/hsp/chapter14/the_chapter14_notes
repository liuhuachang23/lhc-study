泛型
    不使用泛型的不足之处：[Generic01]
        1)不能对加入到集合 ArrayList中的数据进行约束, 不安全 (例题中有体现)
        2)遍历的时候,需要进行类型转换,如果集合中的数据量比较大,对效率有影响

    使用泛型的好处 [Generic02]
        (1) 编译时, 检查添加元素的类型, 提高了安全性
        (2) 减少了类型转换的次数, 提高效率
        (3) 不在提示编译警告

    泛型介绍

        泛型可以理解为
            泛型就是表示数据类型的一种数据类型
            泛(广泛)型(类型) =可以将它指定为=> Integer, String, Dog，等等
        1) 泛型又称参数化类型, 是jdk5.0出现的新特性, 解决数据类型的安全性问题
        2) 在类声明或实例化时只要指定好需要的具体的类型即可
        3) java泛型可以保证如果程序在编译时没有发出错误警告,运行时就不会产生
           ClassCastException异常, 同时, 代码更加简洁, 健壮
        4) 泛型的作用是: 可以在类声明时通过一个 标识 表示 类中某个属性的类型、某个方法的返回值
           的类型、是某个方法的参数类型

    泛型的语法

        1.泛型的声明
          interface接口<T>{} 和 class类<K,V>{}  //比如: List, ArrayList
          说明:
            1)其中， T、K、V 不代表值，而是表示类型
            2)任意字母都可以, 常用T表示, 是Type缩写
        2.泛型的实例化:
          要在类名后面指定类型参数的值（类型），如：
          1) List<String> strList = new ArrayList<>();
          2) Iterator<Customer> iterator = customers.iterator();

    泛型使用的注意事项和细节
        1) interface List<T> {}，public class HashSet<E> {} ..等等
            说明：T、E 只能是引用类型
        2) 在指定泛型类型的具体类型后，可以传入该类型的或者其子类类型
        3) 泛型使用形式
            ArrayList<Integer> list = new ArrayList<Integer>();
            ArrayList<Integer> list3 = new ArrayList<>();  //简写
        4) 泛型是默认存在的，当我们没有写，会默认为Object类型
            ArrayList list = new ArrayList(); 等价于：
            ArrayList<Object> list = new ArrayList<>();
            建议使用下面这种写法

自定义泛型

    1、自定义泛型类：
         class 类名<T,R...>{
            //成员
         }

        注意细节 [ CustomGeneric_ ]
            1) 普通成员可以使用泛型(属性,方法)
            2) 使用泛型的数组,不能初始化
            3) 静态方法和静态属性不能使用类的泛型
            4) 泛型的类型,是在创建对象时确定的(因为创建对象时,需要指定确定类型)
            5) 如果在创建对象时,没有指定类型,默认为Object

    2、自定义泛型接口
          interface 接口名<T, R ...>{

          }

        注意细节
            1) 接口中, 静态成员也不能使用泛型(这个和泛型类规定一样)
            2) 泛型接口的类型, 在继承接口或者实现接口时确定
            3) 没有指定类型, 默认为Object

    3、自定义泛型方法

          修饰符<T, R, ...>返回类型 方法名(参数列表){
          }

        注意细节
        1) 泛型方法, 可以定义在普通类中, 也可以定义在泛型类中
        2) 当泛型方法被调用时, 类型会确定
        3) public void hi(T t){}
           该方法不是泛型方法(修饰符后面没有<T..>), 只是使用了泛型