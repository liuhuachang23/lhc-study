public class DataTypeTest05
{
	public static void main(String[] args){
	
		//100L是long类型字面值
		//x是long类型变量
		//不存在泪下的转换，直接赋值
		long x = 100L;

		//x变量是long类型，8个字节
		//y变量是int类型，4个字节
		//以下程序可以编译通过吗？
		//编译报错，大容量不能直接赋值给小容量
		//int y = x;

		//大容量转换成小容量，需要进行强制类型转换
		//强制类型转换需要加"强制类型转换符"
		//加上强制类型转换符之后编译通过了，但是可能会损失精度。
		//所以强制类型转换谨慎使用，因为损失精度之后可能损失严重

		//强转原理
			//原始数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
			//强转之后的数据：00000000 00000000 00000000 01100100
			//将左边的二进制砍掉【所以的数据强转的时候都是这样完成的】
		int y = (int)x;
		System.out.println(y);
		
		//原始数据：00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
		//强转之后的数据：10000000 00000000 00000000 00000000  【目前存储在计算机内部，计算机存储数据都是采用补码的形式存储】
		//所以10000000 00000000 00000000 00000000现在是以一个补码形式
		//将以上补码转换成原码就是最终结果
		long k = 2147483648L;
		int e = (int)k;
		System.out.println(e); //损失精度严重，结果是负数  【-2147483648】

		//分析以下程序是否可以编译通过？
		//依据目前所学内容，以下程序是无法编译通过
		//理由：50是int类型的字面值，b是byte类型的变量，显然是大容量转换成小容量
		//但是，在实际编译的时候，以下代码编译通过了，这说明：在Java语言当中，当一个整型字面值没有超出byte类型取值范围的话，该字面值可以直接赋值给byte类型的变量。
		byte b = 50; //可以

		byte c = 127; //可以

		//编译报错，128这个int类型字面值已经超出了byte类型的取值范围，不能直接赋值给byte类型的变量
		//byte b1 =128;

		//纠正错误，需要使用强制类型转换符
		//但是一点会损失精度
		//原始数据：00000000 00000000 00000000 10000000
		//强转后的数据：10000000【计算机存储数据都是采用补码的形式存储】
		byte b1 = (byte)128; //结果为-128
		System.out.println(b1);	
	}

}