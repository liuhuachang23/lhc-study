类

类的五大成员：属性、方法、构造器、代码块、内部类

1、类变量(属性)
    1）static变量是所有对象共享的（同一个类）
    2）static变量，在类加载的时候就生成了

    类变量的使用事项和细节讨论
    1）什么时候使用类变量：
        当我们需要让某个类的所有对象都共享一个变量时，可以考虑使用类变量
        比如：定义学生类，统计所有学生一共交了多少学费
    2）类变量与实例变量的区别
        类变量是该类所有对象共享的，而实例变量是每个对象独享的
    3） 类变量可以被继承

2、类方法（静态方法）

    什么时候使用类方法
        当方法中不涉及任何和对象相关的成员时，则可以将方法设计成静态方法，提高开发效率
        比如一些工具类中的方法：utils Math类、Arrays类、Collections类

    类方法使用注意事项和细节
        1）类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区
        2）类方法中不允许使用和对象有关的关键字（如：this 和 super），普通方法可以
        3）静态方法只能访问静态成员，普通方法都可以访问
        4）静态方法可以声明静态属性，也可以声明非静态属性。而普通方法不能声明静态属性
        5）类方法可以通过类名调用，也可以通过对象名调用

static修饰的 方法和属性 可以被继承，但是不能被子类重写，所以无法实现多态
    package hsp.chapter10.static_.StaticExtends


main方法

    解释main方法的形式：public static void main(String[] args){}
    1） main方法时虚拟机调用
    2） java虛拟机需要调用类的main()方法，所以该方法的访问权限必须是public
    3） java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static
    4） 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所
        运行的类的参数,案例演示，接收参数
    5） java 执行的程序 参数1 参数2 参数3

    特别提示
    1） 在main(方法中，我们可以直接调用main方法所在类的静态方法或静态属性,
    2） 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能
        通过这个对象去访问类中的非静态成员，

代码块

    1）普通的代码块
                在创建对象实例时，会被隐式的调用被创建一次就会调用一次
                如果只是使用类的静态成员时(不会创建对象)，普通代码块不会执行
                (普通代码块 可以理解为 构造器的补充)

    2）静态代码块
        作用是对类进行初始化，而且它随着 类的加载而执行，并且只会执行一次
        如果是普通代码块，每创建一个对象，就会执行一次

    3）类什么时候被加载：
       （1）创建对象实例时(new)
       （2）创建子类对象实例时（父类也会被加载，先加载父类，然后子类）
       （3）使用类的静态成员时（静态属性、静态方法）

    4）注意事项：
        （1）静态代码块，只能调用静态成员
        （2）普通代码块可以使用任何成员
        （3）构造器的最前面其实隐含了 super() 和 调用普通代码块
        （4）静态相关的代码块，属性初始化，在类加载时，就执行完毕

    创建一个子类对象时（静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造方法）的调用顺序
        package hsp.chapter10.codeblock.CodeBlockDetail04

        1）父类的 静态代码块、静态属性初始化（看前后顺序，谁在前面谁先）
        2）子类的 静态代码块、静态属性初始化（看前后顺序）
        3）子类构造器 第一行：super() 到父类构造器
        4）父类构造器 第一行：super()
        5）父类构造器 第二行：父类的 普通代码块、普通属性初始化（看前后顺序）
        6）父类构造器全部内容初始化完成后 --> 转回子类构造器
        7）子类构造器 第二行：子类的 普通代码块、普通属性初始化（看前后顺序）
        8）子类构造器剩余内容进行初始化


单例模式

final关键字
    final使用细节

    <final修饰属性>
      1）final修饰的属性称为常量(一般用 XX_XX_XX 来命名)
      2）final 修饰的属性在定义时,必须赋初始值,并且以后不能在修改 (例子:FinalExercise01)
          赋初始值可以在
          (1)定义时赋值
          (2)构造器中赋值(如果是静态的这种方式不能用)
          (3)代码块中赋值(静态在静态代码块,普通在普通代码块)

    <final修饰类>
      1）final类不能被继承,但是可以实例化对象
      2）String类 和 8种包装类 都被final修饰了

    <final修饰方法>
      1）不是final类,若含有final修饰的方法,该方法可以被继承,但是不能被重写
      2）final不能修饰构造方法(构造器)
          final方法是约束子类不能覆盖，但是构造方法本身不允许子类继承。谈不上覆盖。
          （构造方法不是通过覆盖得到的，所以没必要用final修饰）

    <final搭配static>
        1）final 和 static 往往搭配使用效率更高,不会导致类加载,底层编译器做了优化处理
           说明：之前说过使用类成员（static修饰的属性或者方法）会导致类加载，但是final 和 static 一起使用，不会导致类加载

抽象类
    1.抽象类怎么定义？ 在class前面加abstract关键字就行。
    2.抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。
    3.抽象方法不能使用private final static 修饰，因为关键字都是和重写违背的
    4.抽象类的子类可以是抽象类，也可以是非抽象类。
    5.抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法供子类使用。
    6.抽象类中不一定有抽象方法，但抽象方法必须出现在抽象类当中。
    7.抽象方法怎么定义：
        public abstract void doSome();
    8.一个非抽象类继承一个抽象类，必须将抽象类中的抽象方法进行实现（覆盖/重写），除非他声明为抽象类。
    9.抽象类可以有任何成员【抽象类本质还是类】，比如；普通方法、构造器、静态属性等等

接口
     1、什么是接口
         1）接口是一种引用数据类型
         2）接口是完全抽象的（抽象类是半抽象） 或者也可以说接口是特殊的抽象类
         3）接口怎么定义，语法是什么？

               [修饰符列表] interface 接口名{}

         4）接口支持多继承,一个接口可以继承多个接口
         5）接口中只包含两部分，一部分是：常量。一部分是：抽象方法。接口中没有其他内容
            (jdk8及以上 接口可以有 静态方法，默认方法，也就是说接口中可以有方法体的实现)
         6）接口中所有元素但是public修饰（都是公开的）
         7）接口中抽象方法定义时：public abstract修饰符可以省略
         8)接口中的常量的 public static final 可以省略（所以在接口中定义的变量都是常量）

     2、接口的基础语法:
         1)类和类之间叫继承,类和接口之间叫实现(可以看做继承)

             继承使用extend关键字完成
             实现使用implements关键字完成

         2)当一个非抽象的类实现接口的话,必须将接口中所有的抽象方法全部实现(重写/覆盖)

     4、接口使用细节

        1)接口不能被实例化
        2)接口中的所以方法都是public方法，接口中的抽象方法，可以不
        3）一个普通的类实现接口，就必须吧接口中的所有方法都实现
        4）抽象类实现接口，可以不用实现接口的方法
        5）接口中的属性访问形式：接口名.属性名
        6）接口不能继承其他的类，但是可以继承其他的多个接口
            interface A extends B,C{}
        7）接口的修饰符只能是public 和 默认 （这一点和类一样）

     3、接口和抽象类的区别：

        1） 抽象类是半抽象，接口是完全抽象
        2） 抽象类中有构造方法，接口中没有构造方法
        3） 类和接口之间支持多继承，类和类之间只能单继承
        4） 一个类可以同时实现多个接口，一个抽象类只能继承一个类（单继承）
        5） 接口中只允许出现常量和抽象方法

     4、接口和继承解决的问题不同
           继承的价值主要在于：解决代码的复用性和可维护性
           接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法，所以接口更加灵活

           接口是对java单继承机制的一种补充
           接口在一定程度上实现代码的解耦【接口规范性 + 动态绑定机制】

     5、类与类之间的关系
        类型和类型之间的关系
             is a （继承）  has a （关联）  like a（实现）

                   is a :
                       Cat is a Animal (猫是一个动物)
                       凡是能够满足 is a 的表示"继承关系"

                   has a :
                       I has a Pen (我有一支笔)
                       凡是能满足 has a 关系的表示"关联关系"
                       关联关系通常以"属性"的形式存在.

                   like a :
                       cooker like a FoodMenu (厨师像一个菜单一样)
                       凡是能满足 like a 关系的表示"实现关系"
                       实现关系通常是: 类实现接口

内部类 package hsp.chapter10.innerclass;

    一个类的内部又完整的嵌套另一个类结构。被嵌套的类称为内部类，嵌套其他类的类称为外部类
    内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系

    内部类的分类
        1.定义在外部类局部位置上（比如方法体内）
            1）局部内部类（有类名）
            2）匿名内部类（没有类名，重点！！！！）
        2.定义在外部类的成员位置上
            1）成员内部类（没有static修饰）
            2）静态内部类（使用static修饰）

    1.局部内部类的使用
        1)匿名内部类的语法比较奇特,匿名内部类即是一个类的定义,同时它本身也是一个对象
          它既有定义类的特征,又有创建对象的特征,因此它可以调用匿名内部类方法
        2）可以直接访问外部类的所以成员，包含私有的
        3）不能添加访问修饰符（因为他的地位就是一个局部变量），但是可以使用final修饰（因为局部变量也可以使用final）
        4）作用域：仅仅在定义它的方法或者代码块中
        5）局部内部类-->访问-->外部类的成员【直接访问】
        6）外部类-->访问-->局部内部类的成员【创建对象（在作用域内），在访问】

        记住
        1）局部内部类定义在方法/代码块中
        2）作用域在方法体或者代码块中
        3）本质仍然是一个类

        7）外部其他类-->不能访问-->局部内部类（因为 局部内部类的地位就是一个局部变量）
        8）如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员名）

    2.匿名内部类 (这个非常重要，详细分析见：AnonymousInnerClass 和 AnonymousInnerClassDetail)

       匿名内部类的使用 参照局部内部类（都一样，本质都是局部变量）

       匿名内部类的最佳实践：InnerClassExercise01 和 InnerClassExercise02

    3.成员内部类 (定义在外部类的成员位置,没有static修饰)

          1.可以直接访问外部类的所有成员,包括私有的
          2.可以添加任意访问修饰符(public protected 默认 private),因为它的地位就是一个成员
          3.作用域:和外部类的其他成员一样,为整个类体
          4.成员内部类-->访问-->外部类成员(直接访问)
          5.外部类-->访问-->成员内部类(创建对象,在访问)
          6.外部其他类-->访问-->成员内部类(2种方式)  MemberInnerClass01
            1) Outer08.Inner08 inner081 = new Outer08().new Inner08();
            2) 在外部类中,编写一个方法(把这个内部类当成外部类的一个属性，这个方法就相当于这个属性的get方法，在这个方法里面创建内部类对象，并返回)
               在外部其他类中：Outer08 outer08 = new Outer08()
               在调用这个方法：outer08.getInner08()
            两种方法本质还是一样的

          7.如果外部类和成员内部类的成员重名时,成员内部类访问的话,默认就近原则,如果想访问外部类成员,可以使用(外部类.this.成员)

        补充：
          1.成员内部类：不能含有static成员，但是可以访问外部类的所有成员包括static成员
            原因：内部类是非static的，那么这个内部类就依赖于外部类的具体对象，所以这个内部类可以访问外部的非static成员
          2.成员内部类：可以有常量，包括static修饰的常量（如：static final int b = 1;）
            原因：java中吧常量放在了内存中常量池，加载常量是不需要类加载的

    4.静态内部类 (定义在外部类的成员位置,有static修饰)

        1.可以直接访问外部类的所有静态成员,包括私有的,但不能直接访问非静态成员
        2.可以添加任意访问修饰符(public protected 默认 private),因为它的地位就是一个成员
        3.作用域:和外部类的其他成员一样,为整个类体

        4.静态内部类-->访问-->外部类成员(比如属性),直接访问

        5.外部类-->访问-->静态内部类
             1）访问 静态内部类的静态成员 类名.静态成员（包括属性和方法）
             2）访问 静态内部类的非静态成员 先创建对象 引用.非静态成员（包括属性和方法）

        6.外部其他类-->访问-->静态内部类(访问修饰符要满足) StaticInnerClass01
            1）访问 静态内部类的静态成员 外部类名.静态内部类名.静态内部类的静态成员（包括属性和方法）
            2）访问 静态内部类的非静态成员 ()
                方式1：Outer10.Inner10 inner10 = new Outer10.Inner10();
                      inner10.非静态成员
                方式2：编写一个方法,可以返回静态内部类的对象实例（把Inner10当成外部类的一个静态属性，这个方法就相当于属性的get方法）
                      这个方法可以为静态方法，也可以为非静态方法，

        7.如果外部类和静态内部类的成员重名时,静态内部类访问的话,默认就近原则,如果想访问外部类成员,可以使用(外部类.成员)

        补充：
            静态内部类：可以有非静态成员，但是不能访问外部类的非静态成员
            原因：这个内部类被声明为static，即该内部类属于外部类的范畴，不依赖于外部类的具体对象，那么该内部类只
                 能访问外部类的static方法，因为外部类的非static方法依赖于外部类的具体对象